# Архитектура для стресс-режима
## Высокоуровневая архитектура MVP 
1. Пользователь пишет класс и наследует его от `Node` (то есть переопределяет метод `onMessage(message : Message)`). Также его класс в конструктор принимает instance интерфейса `Environment`, через который присходит отправка сообщений.
1. `Environment` позволяет отправить сообщение `Message`. 
1. `Message` хранит в себе текст сообщения, `sender`, `receiver`, `headers` -- `HashMap<String, String>`, набор произвольных заголовков.
1. Пользователь задаёт конфигурацию системы в `DistributedOptions`. Параметрами являются:
    * Число узлов (называется `threads`, хотя тут было бы более подходящим другое название)
    * Вероятность, с которой доставляются сообщения: `networkReliability`
    * Сколько раз максимум может продублироваться одно сообщение: `duplicationRate`
    * Какой порядок доставки гарантирует система (синхронный, FIFO, асинхронный)
    * Могут ли в системе отказывать узлы (`allowNodeFails`)
    * Могут ли узлы восстанавливаться после падения (`supportNodeRecovery`)
    * Максимальное число узлов, которое может отказать (`maxNumberOfFailedNodes`)
    * Максимальное число сообщений, которые могут быть отправлены одним процессом
1. Помимо конфигурации системы, задаётся конфигурация теста. То есть:
    * Число итераций
    * Число вызовов функций в течении одной итерации
1. Далее по `DistributedOptions` создаётся `DistributedCTestConfiguration`, а потом из неё `DistributedStrategy`.
1. Внутри `DistributedStrategy` запускается `DistributedRunner` число итераций раз.
1. Внутри `Runner` каждый раз происходит запуск определённого сценария. 
## Как изнутри будет устроен `Runner` для MVP
1. Есть набор `testInstances`, в котором хранятся `instance`'ы `Node`'ов. 
1. 
